# Day 5 試験対策

出典書籍「徹底攻略 Java SE 8 Gold 問題集」第11章総仕上げ問題より、次の3問を取り上げて詳しく解説する。

* 問題 26 - AutoCloseable, try-with-resources
* 問題 10 - Paths.get(), Files.lines(), list(), readAllLines()
* 問題 44 - Files.readAllLines(), Path

## 問題 26

**設問**

次のプログラムを実行したときの結果として正しいものを選びなさい。(1つ選択)

    設問のコード
    NetworkMonitor.java
     1:  public class NetworkMonitor implements AutoCloseable {
     2:     public void close() throws Exception {
     3:        System.out.println("Monitor closed");
     4:     }
     5:
     6:     public void monitor() throws Exception {
     7:        System.out.println("Monitoring...");
     8:        throw new Exception("Unable to monitor.");
     9:     }
    10:  }
    
    PacketFilter.java
     1:  public class PacketFilter implements AutoCloseable {
     2:     public void close() throws Exception {
     3:        System.out.println("Filter closed.");
     4:     }
     5:
     6:     public void filter() {
     7:        System.out.println("filtering...");
     8:     }
     9:  }
     
    Unknown
    11:  try (NetworkMonitor nm = new NetworkMonitor();
    12:       PacketFilter pf = new PacketFilter()) {
    13:       nm.monitor();
    14:       pf.filter();
    15:  } catch(Exception e) {
    16:     System.out.println(e.getMessage());
    17:  }

**選択肢**

    A.  Monitoring...
        Unable to monitor.
    B.  Monitoring...
        Unable to monitor.
        Filter closed.
    C.  Monitoring...
        Unable to monitor.
        Monitor closed.
    D.  Monitoring...
        Filter closed.
        Monitor closed.
        Unable to monitor.

**出典書籍の解答と解説**

正解 D

設問のコードでは、NetworkMonitorクラスとPacketFilterクラスを**try-with-resources文**で利用しています。NetworkMonitorオブジェクトのmonitorメソッドの実行では「Monitoring...」が表示され、その後、例外をスローしているため「Unable to monitor」が表示されます (最後に表示されます)。

try-with-resources文の「()」内のオブジェクトを生成可能なクラスは**AutoCloseableインタフェース**をimplementsして**closeメソッド**を実装しているクラスです。closeメソッドは、例外の発生有無にかかわらずtry-with-resources文のブロックを抜ける際に必ず呼び出されます。また、closeメソッドが呼び出される順番はインスタンスを生成した順番の逆順となります。したがって、PacketFilterクラスのcloseメソッドが呼び出されて「Filter closed.」が表示され、次に「Monitor closed.」が呼び出されます。以上のことから、選択肢Dが正解です。


## 問題 10

**設問**

テキストファイル「sample.txt」のすべての内容を表示するために、以下の「//line n1」の行に挿入するコードとして正しいものを選びなさい。(1つ選択)

    設問のコード
    11:  try {
    12:     Path file = Paths.get("sample.txt");
    13:     // line n1
    14:  } catch (IOException e {
    15:     e.printStackTrace();
    16:  }

**選択肢**

    A.  Stream<String> stream = Files.lines(file);
        stream.forEach(s -> System.out.println(s));
    B.  List<String> stream = Files.list(file);
        stream.stream().forEach(s -> System.out.println(s));
    C.  Stream<String> stream = Files.readAllLines(file);
        stream.forEach(s -> System.out.println(s));
    D.  List<String> stream = Files.allLines(file);
        stream.stream().forEach(s -> System.out.println(s));

**出典書籍の解答と解説**

正解 A

**Filesクラス**は、テキストファイルの内容を読み取って各行を処理するためにいくつかのメソッドを提供しています。設問では「すべての内容を表示する」と記述されているので、読み取ったすべての内容をStream&lt;String>型オブジェクトとして返す**linesメソッド**を使用している選択肢Aが正解です。

その他の選択肢が誤りとなる理由も確認しておきましょう。

選択肢Bで使用しているFilesクラスの**listメソッド**はStream&lt;Path>型オブジェクトを返すため、List&lt;String>型変数の宣言は誤りです。選択肢Cで使用しているFilesクラスの**readAllLinesメソッド**はList&lt;String>型オブジェクトを返すため、Stream&lt;String>型変数の宣言は誤りです。選択肢DのallLinesというメソッドはFilesクラスでは宣言されていません。


## 問題 44

**設問**

次のプログラムをコンパイル、実行したときの結果として正しいものを選びなさい。ただし、dataディレクトリとファイルは存在するものとする。(1つ選択)

    11:  Path[] files = {
    12:     Paths.get("data/log.txt"),
    13:     Paths.get("data/sales.csv"),
    14:     Paths.get("data/customer.xls")
    15:  };
    16:
    17:  Stream.of(files)  // line n1
    18:     .filter(p -> p.toString().endsWith("csv"))
    19:     .forEach(p -> {
    20:        try {
    21:           Files.readAllLines(p).stream().forEach(System.out::println); // line 2
    22:        } catch (IOException e) {
    23:           e.printStackTrace();
    24:        }
    25:     });

**選択肢**

    A.  sales.csvファイルの内容がすべて表示される
    B.  // line n1の行でコンパイルエラーとなる
    C.  // line n2の行でコンパイルエラーとなる
    D.  実行時に例外がスローされる


**出典書籍の解答と解説**

正解 A

設問のコードではPathオブジェクトが格納された配列filesを生成し、その配列を**Streamクラス**の**ofメソッド**に渡してStream&lt;Path>オブジェクトを生成しています。

次にfilterメソッドを使用してパス文字列が「csv」で終わる**Path**オブジェクトだけを抽出し、Filesクラスの**readAllLinesメソッド**を使用してファイル内のすべての行を取得しています。readAllLinesメソッドは、ファイル内のすべての行を文字列として格納したList&lt;String>を返すため、streamメソッドを使用してStream&lt;String>オブジェクトを取得し、**forEachメソッド**を使用してその内容をすべて画面に表示することができます。したがって、すべてのコードは問題なくコンパイルと実行ができ、sales.csvファイルの内容が画面に表示されるため、選択肢Aが正解です。

**詳細**

設問のコードが問題なくコンパイルできることを確認すべく、登場した主要なメソッドの定義を次に示す。

    java.nio.file.Paths
     1:  public final class Paths {
     2:     public static Path get(String first, String... more);
    ??:  }
    
    java.util.stream.Stream
     1:  public interface Stream<T>
     2:     static <T> Stream<T> of(T... values);
     3:     Stream<T> filter(Predicate<? super T> predicate);
     4:     void forEach(Consumer<? super T> action);
    ??:  }
    
    java.nio.file.Path
     1:  public interface Path {
     2:     String toString();
    ??:  }
    
    java.nio.file.Files
     1:  public final class Files {
     2:     public static List<String> readAllLines(Path path) throws IOException { ... }
    ??:  }
    
    java.util.Collection
     1:  public interface Collection<E> extends Iterable<E> {
     2:     default Stream<E> stream();
    ??:  }




## 出典

徹底攻略 Java SE 8 Gold 問題集

* 2018年1月11日 第1版第2刷
* 著者: 米山学
* 編者: 株式会社ソキウス・ジャパン
* 発行所: 株式会社インプレス
* ISBN 978-4-295-00003-7


(Day 5, 2/2 終わり)
